/*
	program:	metal2hst.c
	author:		Peng Yi at JHU
	date:		Dec. 28, 2013
	purpose:	analyze LAMMPS dump file for metal simulations
	note:		require setup file
	update:
			Dec. 28, 2013	Created based on lammps2hst.c
*/

#define __MAIN_PROGRAM
#include "header.h"

#define CAP		5		// largest nuclei considered still the melt
#define M2HDEBUG	1
#define SIZECAP		5
#define DEN_BIN		12

#undef  CODE

#include "correlation.h"		// autocorrelation calculation module

//==============================//
//	Global variables	//
//==============================//
long		timestep;
int 		nmaxp2_1[10];		// nmax using p2 nucleus definition
int 		nmaxp2_2[10];
int 		nmaxp2_3[10];
int 		nmaxp2_4[10];
float		rshift2;		// shift of the biggest nucleus

float		R02;
float		Rg2[MAXNMOLS];		// Radius of gyration square
float		aveRg2;			// average Rg2 for the system
float		avexRg2, avemRg2;	// average Rg2 for xtal and melt phases
int		nRg2, nxRg2;
vector		smoothresult;
float		rgx2[MAXNMOLS], rgy2[MAXNMOLS], rgz2[MAXNMOLS];
float		avergx2, avergy2, avergz2;

vector		com_sys,		// com of system
		com_sysinit,		// com of initial system
		com_syslast,		// com of previous system
		com_init[MAXNMOLS],	// com of each chain in the beginning
		com_last[MAXNMOLS];	// com of each chain in the previous dump
vector		dr_sys;			// vector of system drift
float		d2initave,		// average displacement w.r.t. to the beginning
		d2lastave,		// average displacement w.r.t. to previous dump
                d2sys, d2syslast;
float		asphericity;		// asphericity of the box

double		lam1, lam2, amo1, amo2;	// thickness of lamellae and interface
double		v2, vf2, vcom2;		// velocity and kinetic energy analysis

//==============================================//
//	Function Declarations and Definitions	//
//==============================================//
void		output_Rg();				// Output Rg analysis
void 		output_pre(FILE *);			// Output pre-analysis results
void 		read_pre(FILE *, long timestep);	// Input pre-analysis results
void 		output_conf(FILE *, long timestep);	// Output configuration file
void 		output_carfile(FILE *);			// Output conf. to .car file
void 		output_pdbfile(FILE *, FILE *, long, double, double, double);	// to .pdb file
void 		output_xyzfile(FILE *);
void		output_Zinput(FILE *);			// Output to Z code input file
void		Seg_Type(int);

char *Element(long t, char *s)
{
   double	mass = type[t].M;

   s[0]		=	0;
/*
   if (14==mass || 15==mass)	strcpy(s, "C");
   else if (1.01==mass)		strcpy(s, "H");
   else if (28.086==mass)	strcpy(s, "Si");
   else if (26.982==mass)	strcpy(s, "Al");
   else if (16==mass)		strcpy(s, "O");
*/
   strcpy(s, "C");
   return	s;
}

void Print_hst(FILE *fPtr)
{
   long		i;
   static long	init_hst = 1;

   if (init_hst) {
      init_hst	=	0;
      // Print variable names
      fprintf(fPtr, "Timestep ");
      fprintf(fPtr, "Epot ");
      fprintf(fPtr, "Volume ");
      fprintf(fPtr, "Pressure ");

      fprintf(fPtr, "Lx Ly Lz ");	// box dimensions
      fprintf(fPtr, "xy xz yz ");	// triclinic box parameters

      fprintf(fPtr, "P2 P2m P2z ");	// orientation order parameters
      fprintf(fPtr, "Transfrac ");
      fprintf(fPtr, "Xtal ");
      fprintf(fPtr, "RealXtal ");
      fprintf(fPtr, "Nnucl ");

      fprintf(fPtr, "Nmaxp2 2ndNmaxp2 ");

      fprintf(fPtr, "Q6 ");
      fprintf(fPtr, "rshift2 ");

      fprintf(fPtr, "E_bond ");
      fprintf(fPtr, "E_angle ");
      fprintf(fPtr, "E_tors ");
      fprintf(fPtr, "E_lj ");
      fprintf(fPtr, "E_ljcorr");

      fprintf(fPtr, "\n");
   }

   // Write variable values

   fprintf(fPtr, "%-6ld ", timestep);
   fprintf(fPtr, "%8.4f ", v[0].tot);
   fprintf(fPtr, "%8.4f ", BOX[0].vol);
   fprintf(fPtr, "%8.4f ", BOX[0].pres);
   fprintf(fPtr, "%5.3f %5.3f %5.3f ", BOX[0].lx, BOX[0].ly, BOX[0].lz);
   fprintf(fPtr, "%5.3f %5.3f %5.3f ", BOX[0].xy, BOX[0].xz, BOX[0].yz);

   fprintf(fPtr, "%6.4f %6.4f %6.4f ", P2[0], P2M[0], P2z[0]);
   fprintf(fPtr, "%6.4f ", transfrac[0]);
   fprintf(fPtr, "%4ld ", Xtal[0]);
   fprintf(fPtr, "%4ld ", realXtal[0]);
   fprintf(fPtr, "%4ld ", Nnucl[0]);

   for (i=0; i<2; i++)      fprintf(fPtr, "%4d ", nmaxp2_3[i]);
/*
   for (i=0; i<2; i++)      fprintf(fPtr, "%4d ", nmaxp2_1[i]);
   for (i=0; i<2; i++)      fprintf(fPtr, "%4d ", nmaxp2_2[i]);
   for (i=0; i<2; i++)      fprintf(fPtr, "%4d ", nmaxp2_3[i]);
   for (i=0; i<2; i++)      fprintf(fPtr, "%4d ", nmaxp2_4[i]);
*/

   fprintf(fPtr, "%6.4f ", Q6[0]);
   fprintf(fPtr, "%6.4f ", rshift2);

   fprintf(fPtr, " %8.4f", v[0].stretch);
   fprintf(fPtr, " %8.4f", v[0].bending);
   fprintf(fPtr, " %8.4f", v[0].torsion);
   fprintf(fPtr, " %8.4f", v[0].lj);
   fprintf(fPtr, " %8.4f", v[0].ljcorr);

   fprintf(fPtr, "\n");
   fflush(fPtr);
   return;
}


//======================//
//	Main Program	//
//======================//
int main(int argc, char *argv[])
{
   tim=(int *)malloc(sizeof(int));     	//random number generator
   seed=(long *)malloc(sizeof(long));
   *tim=(int)time(NULL);
   *seed= -1*(*tim);           		//seed must start out as a negative long

   time_t	t	=	time(NULL), prog_start, prog_end, start, end;
   molstruct	*moli;
   long		i, j, k, system, m, n, id, maxid, max, size;
   long		siteid, molid, type;
   int		nx, ny, nz, nx1, ny1, nz1;
   double	x, y, z, 			// coordinates
		vx, vy, vz, 			// velocity
		fx, fy, fz,			// force
		xhi, xlo, yhi, 			// box lower boundary
		ylo, zhi, zlo,			// box upper boundary
		xy=0, xz=0, yz=0;		// triclinic parameter
   long		LENGTH, accum;			// chain length variables

   // dummy variables
   
   long		ltemp1, ltemp2, ltemp3;
   double	temp, temp1, temp2, temp3;
   double	tensor[6];
   vector	rtemp, rtemp1, rtemp2;

   // file variables
   
   char		infile[32][255], filein[80], filename[80], procid[16];
   char		s[80], ff[80], par[80], dummy[255];
   char		atomname;			// for visualization file output
   FILE		*fin, *fhst, *fpre;		// input and analysis output
   FILE		*fxyz;
   FILE		*fcar, *fconf, *fpdb, *fdat;	// configuration/visualization output
   FILE		*fZfile;			// Z-code input configuration file
   FILE		*fcolor;

   int		preflag		= 0;		// flags for input command line
   int		polydisperse	= 0;
   int		confflag	= 0;
   int		carflag		= 0;
   int		pdbflag		= 0;
   int		xyzflag		= 0;
   int		Zflag		= 0;
   int		nfiles=1, ifile;		// number of input files 
   int		nframe, dnframe=1;		// analyze only every dnframe
   int		previous_timestep=-1;
   int		starttime=-1;
   int		endtime=-1;

   static int	clistinit=1, cominit=1;	

   vector		con;			// center of nucleus
   static vector	rO;			// original position of nucleus

   // a group of beads
   
   vector	rbead[MAXNMOLS*MAXNMOLSITES];

   // variables to characterize nucleus, chains, etc at ONE timestep

   long		nsites;
   int 		nuclid;
   int		nmaxid;					// nuclid of the largest nucleus
   beadstruct	nucleus[MAXNMOLS*MAXNMOLSITES];		// group beads in the same nucleus
   vector	com[MAXNMOLS];				// average center of mass
   long		ncom[MAXNMOLS];
   int		nchainmax;				// # of chains in the largest nucleus

   // chain rotational angle distribution

   vector	chainface;
   double	orient;
   long		orientdist[180];

   // density profile

   long		direct;
   double	density[100];
   vector	rsite[MAXNMOLS * MAXNMOLSITES];	

   // velocity statistics
 
   double	dvel=0.001;
   double	ave_vx, ave_vy, ave_vz;
   double 	velmax=0.0, velmin=0.0;
   double	vel_distx[101], vel_disty[101], vel_distz[101];
 
   // variables to AVERAGE over a number of timesteps

   long		*Nn;				// size dist. of nucleus size
   long		ntot, maxnmax;			// total number of nuclei for normalization
   long		xbeadpos[MAXNMOLSITES];		// xtal bead position on chain
   float	avePtt, avePttt;		// prob. of 2 or 3 consecutive trans states
   float	stdPtt, stdPttt;
   float	*Rg2nucl;			// Rg2 of nucleus as a function of size

   // segment statistics variables

   int 		head, tail, seg_on, seg_id, nseg, nxtal, length;
   int 		segment[MAXNMOLS][MAXNMOLSITES];	// segments identification on a chain
							// -- segment[molid][siteid]
   int		ntail, nloop, nbridge, npbrdg, nxseg;	// # of tails, etc
   float	ltail, lloop, lbridge, lpbrdg, lxseg;	// average leng of tails, etc
   float	lfree;	
   int		lsegdist[10][MAXNMOLSITES];		// segment length distribution
   int		nltail[MAXNMOLSITES],			// tail length distribution
   		nlloop[MAXNMOLSITES], 			// loop
		nlbridge[MAXNMOLSITES],			// bridge
                nlpbrdg[MAXNMOLSITES],			// p.b.c bridge
		nlxseg[MAXNMOLSITES],			// xtal stem
		nlfree[MAXNMOLSITES];			// free chain
   int		oldxtal=0, oldnnucl=0,			// xtal variables before segment smoothing
                oldnmax=0, old2nmax=0;
   vector	rhead, rtail;

   // pbc image variables
   
   long		imagen=0;
   double	imagex, imagey, imagez;	

   //------MPI initialization------//
   MPI_numprocs	=	1;			// default value
   MPI_myid	=	0;			// default value

#ifdef myMPI
   MPI_Init(&argc, &argv);
   MPI_Comm_size(MPI_COMM_WORLD, &MPI_numprocs);
   MPI_Comm_rank(MPI_COMM_WORLD, &MPI_myid);
#endif

   if (argc<2 && MPI_myid==0) {
      printf("metal2hst (c) 2013 by Peng Yi at JHU\n\n");
      printf("Usage:\n");
      printf("\tmetal2hst [-option] [x= 0.1 y= 0.1 z= 0.1 n= 1] [dn= 2 nfiles= 2] lammpsdumpfile(s)\n\n");
      printf("Notes:\n");
      printf("\t* -option = \n");
      printf("\t* -pre: generate pre-analysis results\n");
      printf("\t* -conf: configuration file output\n");
      printf("\t* -car: car file output\n");
      printf("\t* -pdb: pdb file output\n");
      printf("\t* -xyz: xyz file output\n");
      printf("\t* x= y= z=: duplicate the system and shift unit vector\n");
      printf("\t* n=: multiple of shift vector\n");
      printf("\t* start=: the timestep that analysis stops\n");
      printf("\t* end=: the timestep that analysis stops\n");
      printf("\t* dn=: only analyze every dn frames\n");
      printf("\t* nfiles=: number of input files if more than 1 (must be <=32)\n");
      printf("\t* \"=\" must immediately follow x or y or z or n or dn\n");
      printf("\t* require setup file\n\n");
      exit(1);
   }

   for (i=1; i<argc-1; i++) {
      strcpy(par, argv[i]);
      if(samestr(par, "-pre"))		preflag		=	1;
      else if (samestr(par, "-conf"))	confflag	=	1;
      else if (samestr(par, "-car"))	carflag		=	1;
      else if (samestr(par, "-pdb"))	pdbflag		=	1;
      else if (samestr(par, "-xyz"))	xyzflag		=	1;
      else if (samestr(par, "-Z"))	Zflag		=	1;
      else if (samestr(par, "x="))	imagex		=	atof(argv[i+1]);
      else if (samestr(par, "y=")) 	imagey		=	atof(argv[i+1]);
      else if (samestr(par, "z=")) 	imagez		=	atof(argv[i+1]);
      else if (samestr(par, "n=")) 	imagen		=	atol(argv[i+1]);
      else if (samestr(par, "start=")) 	starttime	=	atol(argv[i+1]);
      else if (samestr(par, "end=")) 	endtime		=	atol(argv[i+1]);
      else if (samestr(par, "dn=")) 	dnframe		=	atol(argv[i+1]);
      else if (samestr(par, "nfiles="))	nfiles		=	atoi(argv[i+1]);
   }
   for (i=0; i<nfiles; i++) {
      strcpy(infile[nfiles-1-i], argv[argc-1-i]);	// get input filenames
   }

   //---------------------------//
   //	Open output files	//
   //---------------------------//
 
   if (nfiles==1)	strcpy(filein, infile[0]);	// determine output filename
   else			strcpy(filein, "multi");

   sprintf(procid, ".%d", MPI_myid);			// MPI: proc id for output files

#ifdef	myMPI
   //if (MPI_myid==0) {					// ONLY process 0 do the following
#endif
   strcpy(filename, filein);
   strcat(filename, ".hst");
   strcat(filename, procid);
   if (preflag) {
      if ((fhst=fopen(filename, "w"))==NULL )
         Exit("metal2hst", "main", "open .hst file failed.");
   }

   strcpy(filename, filein);
   strcat(filename, ".pre");
   strcat(filename, procid);
   if (preflag) {
      if ((fpre=fopen(filename, "w"))==NULL )		// write .pre file
         Exit("metal2hst", "main", "open .pre file failed.");
   }
   
   strcpy(filename, filein);
   strcat(filename, ".xyz");
   strcat(filename, procid);
   if (xyzflag) {
      if ((fxyz=fopen(filename, "w"))==NULL )
	 Exit("metal2hst", "main", "open .xyz file failed.");
   }
   fcolor=fopen("color","w");

   //------Open optional output files------//

   if (Zflag) {
      fZfile	=	fopen("Z_data", "w");
   }

   strcpy(filename, filein);
   strcat(filename, ".conf");
   strcat(filename, procid);
   if (confflag && (fconf=fopen(filename, "w"))==NULL )
      Exit("metal2hst", "main", "open .conf file failed.");   

   strcpy(filename, filein);
   strcat(filename, ".car");
   strcat(filename, procid);
   if (carflag && (fcar=fopen(filename, "w"))==NULL )
      Exit("metal2hst", "main", "open .car file failed.");

   strcpy(filename, filein);
   strcat(filename, ".pdb");
   strcat(filename, procid);
   if (pdbflag && ((fpdb=fopen(filename, "w"))==NULL || (fdat=fopen("vmd.dat","w"))==NULL))
      Exit("metal2hst", "main", "open .pdb/dat file failed.");

#ifdef	myMPI
   //}
#endif

   if (!M2HDEBUG) {			
      strcpy(filename, filein);
      strcat(filename, ".out");			// every processor does output
      strcat(filename, procid);
      freopen(filename, "w", stdout);		// redirect standard output stream to a file
   }

   //------Write run info. to output file------//
   printf("# BEGINNING OF OUTPUT FILE\n");
   printf("%s\n", asctime(localtime(&t)));

   printf("# metal2hst version: %s\n", M2HVERSION);
   printf("# command: ");
   for (i=0; i<argc; i++) {	
      printf("%s ", argv[i]);	
   }
   printf("\n");
   printf("# number of processor:  %d\n", MPI_numprocs);
   printf("# id of this processor: %d\n", MPI_myid);
   printf("\n");

   prog_start	=	time(NULL);			// to calculate running time

   //-------------------//
   //	Initialization	//
   //-------------------//
   if (M2HDEBUG)	printf("DEBUG: Initialization ...\n");

   InitMols(MAXNMOLS, MAXNMOLS);	// allocate memory for molecules
   GetSetup(argv);			// read in setup file
   InitUnits();				// initialize units for calculation
   InitForcefield();			// initialize Lennard-Jones potential mixing rule

   system	=	0;		// for now 2/14/08, only one system

   InitSample();			// initialize sampling

   nframe	=	-1;

   //------Initialize variable values------//

   for (i=0; i<180; i++) {
      orientdist[i]	=	0;	// chain orientation distribution
   }

   for (i=0; i<MAXNMOLSITES; i++) {
      xbeadpos[i]	=	0;	// crystal bead position
   }

   Nn		=	(long *) calloc(NSITES, sizeof(long));
   ntot		=	0;
   maxnmax	=	0;
   Rg2nucl	=	(float *) calloc(NSITES, sizeof(float));

   for (i=0; i<MAXNMOLSITES; i++) {	// segment length variables
      nlloop[i]		=	0;
      nltail[i]		=	0;
      nlbridge[i]	=	0;
      nlxseg[i]		=	0;
      nlfree[i]		=	0;
   }
   for (i=0; i<10; i++) {
      for (j=0; j<MAXNMOLSITES; j++) {
	 lsegdist[i][j]	=	0;
      }
   }

   //---------------------------//
   //	Start Data Processing	//
   //---------------------------//
   strcpy(filename, filein);
   strcat(filename, ".pre");
   if (!preflag) {
      if ((fpre=fopen(filename, "r"))==NULL )		// read .pre file
         Exit("metal2hst", "main", "open .pre file failed.");
   }

   for (ifile=0; ifile<nfiles; ifile++) {		// multiple input dump files

      fin	=	fopen(infile[ifile], "r");

      if (M2HDEBUG) printf("# Current dump file: %s\n", infile[ifile]);

      while (!feof(fin)) {

	 if (M2HDEBUG)	printf("\nDEBUG: Reading one configuration ...\n");

	 //---------------------------------------------//
	 //	Read one configuration from dump file	//
	 //---------------------------------------------//
	 if (!fgets(dummy, sizeof(dummy), fin)) {	// line 1 of each conf. in dump file
	    break;					// end of file
	 }
	 fscanf(fin, "%ld", &timestep);		fgets(dummy, sizeof(dummy), fin);	// line 2
	 fgets(dummy, sizeof(dummy), fin);						// line 3
	 fscanf(fin, "%ld", &nsites);		fgets(dummy, sizeof(dummy), fin);	// line 4

	 fgets(dummy, sizeof(dummy), fin);						// line 5
	 if (strstr(dummy, "xy"))	PBC = 3;	// PBC=3 for triclinic box

	 fscanf(fin, "%lf%lf", &xlo, &xhi);	if (PBC==3) fscanf(fin, "%lf", &xy); 	// line 6
	 fgets(dummy, sizeof(dummy), fin);
	 fscanf(fin, "%lf%lf", &ylo, &yhi);	if (PBC==3) fscanf(fin, "%lf", &xz); 	// line 7
	 fgets(dummy, sizeof(dummy), fin);
	 fscanf(fin, "%lf%lf", &zlo, &zhi);	if (PBC==3) fscanf(fin, "%lf", &yz);	// line 8
	 fgets(dummy, sizeof(dummy), fin);
	 fgets(dummy, sizeof(dummy), fin);						// line 9

	 xlo	-=	MIN(0.0, MIN(xy, MIN(xz, xy+xz)));		// triclinic box in general
	 xhi	-=	MAX(0.0, MAX(xy, MAX(xz, xy+xz)));
	 ylo	-=	MIN(0.0, yz);
	 yhi	-=	MAX(0.0, yz);

	 system	=	0;
	 BOX[system].lx	=	xhi-xlo;
	 BOX[system].ly	=	yhi-ylo;
	 BOX[system].lz	=	zhi-zlo;
	 BOX[system].xy	=	xy;
	 BOX[system].xz	=	xz;
	 BOX[system].yz	=	yz;

	 temp1	=	MAX( MAX(BOX[system].lx, BOX[system].ly), BOX[system].lz);
	 temp3	=	MIN( MIN(BOX[system].lx, BOX[system].ly), BOX[system].lz);
	 if ( fabs(BOX[system].lx-temp1) > ZERO && fabs(BOX[system].lx-temp3) > ZERO) {
	    temp2	=	BOX[system].lx;
	 }
	 else if ( fabs(BOX[system].ly-temp1) > ZERO && fabs(BOX[system].ly-temp3) > ZERO) {
	    temp2	=	BOX[system].ly;
	 }
	 else if ( fabs(BOX[system].lz-temp1) > ZERO && fabs(BOX[system].lz-temp3) > ZERO) {
	    temp2	=	BOX[system].lz;
	 }
	 asphericity	=	temp1 * temp1 - 0.5*(temp2*temp2 + temp3*temp3);
	 asphericity	/=	(temp1 + temp2 + temp3) * (temp1 + temp2 + temp3) / 9;
    

	 for (i=0; i<nsites; i++) {
	    fscanf(fin, "%ld", &id);
	    fscanf(fin, "%ld", &type);
	    fscanf(fin, "%lf%lf%lf %lf%lf%lf %d%d%d", &x, &y, &z, &vx, &vy, &vz, &nx, &ny, &nz);
	    fscanf(fin, "%lf", &temp1);
	    /*
	    //fscanf(fin, "%lf%lf%lf%lf%lf%lf", tensor, tensor+1, tensor+2, tensor+3, tensor+4, tensor+5);
	    */
	    fgets(dummy, sizeof(dummy), fin);

	    id	--;
	    mol[id].box		=	system;		// for now, only one system
	    mol[id].nsites	=	1;
	    mol[id].type[0]	=	type - 1;	// -1 because lammps index starts from 1

	    // triclinic box in general
	    mol[id].p[0].x	=	x + nx * (BOX[system].lx)
	    				  + ny * (BOX[system].xy) + nz * (BOX[system].xz);
	    mol[id].p[0].y	=	y + ny * (BOX[system].ly) + nz * (BOX[system].yz);
	    mol[id].p[0].z	=	z + nz * (BOX[system].lz);

	    mol[id].pe		=	temp1;

	    /*
	    mol[id].stress[0]	=	tensor[0];
	    mol[id].stress[1]	=	tensor[1];
	    mol[id].stress[2]	=	tensor[2];
	    mol[id].stress[3]	=	tensor[3];
	    mol[id].stress[4]	=	tensor[4];
	    mol[id].stress[5]	=	tensor[5];
	    */
	 }	// One configuration read

	 //output_xyzfile(fxyz);		// output configurations using xyz format

	 unfold();				// unfold by pbc to make a chain continuous in space

	 for (i=0; i<NSYSTEMS; i++) {
	    NMols[i]	=	0;
	    NSites[i]	=	0;
	 }
	 for (moli=mol; moli<mol+NMOLS; moli++) {
	    if ( (i=moli->box) >= 0) {
	       NMols[i]	++;				// total # of mols in certain system
	       NSites[i]	+=	moli->nsites;	// total # of sites in certain system
	    }
	 }

	 for (moli=mol; moli<mol+NMOLS; moli++) {
	    for (i=0; i<moli->nsites; i++)  {
	       moli->flags[i]	=	1;		// activate all the sites on this processor
	       moli->parent[i]	=	i-1;		// initialize parent site
	    }
	    moli->flip		=	0;		// flip to the original direction
	    moli->origin		=	CenterofMass(moli);
	 }

	 //-----------------------------------------------------//
	 //	Skip repeated frames from different input files	//
	 //-----------------------------------------------------//
	 if (ifile>=1 && timestep==previous_timestep) {
	    continue;
	 }
	 previous_timestep	=	timestep;	// check repeat frames

	 //-----------------------------//
	 //	Check timestep range	//
	 //-----------------------------//
	 if (timestep < starttime) {		// starttime=-1 by default
	    continue;
	 }
	 if (endtime > 0 && endtime < timestep) {	// endtime=-1 by default
	    break;
	 }

	 //-------------------------------------//
	 //	Skip (dnframe - 1) frames	//
	 //-------------------------------------//
	 nframe	++;
	 if (mod(nframe, dnframe))	continue;	// analyze every dnframe frames
	
         //-------------------------------------//
	 //	Convert to Z-code input file	//
         //-------------------------------------//
	 
	 if (Zflag && MPI_myid==0) {			// ONLY process 0 do the following
	    output_Zinput(fZfile);			// create init. conf. for Z code
	    continue;
	 }
	 
	 for (i=0; i<NSYSTEMS; i++) {	// Convert other lengths
	    BOX[i].lbox		=	MIN(MIN(BOX[i].lx, BOX[i].ly), BOX[i].lz);
	    // repeatative, just in case .lbox was not converted before
	    BOX[i].vol		=	BOX[i].lx * BOX[i].ly * BOX[i].lz;
	    BOX[i].rc		=	MIN(0.5*BOX[i].lbox, Rc);
	    BOX[i].rb		=	Rb;
	    BOX[i].rv		=	Rv;
	 } 
	// radial("sample");		// sample radial distribution function
	 atom_neighbor();
	 /*
	 for (moli=mol; moli<mol+NMOLS; moli++) {
	    printf("nneigh %d = %d\n", moli-mol, moli->nneigh[0]);
	 }
	 */
	 comm_neigh_para();

	 // find min and max for pe per atom
	 temp1	=	1.0e8;
	 temp2	=	-1.0e8;
	 for (moli=mol; moli<mol+NMOLS; moli++) {
	    temp3	=	moli->pe;

	    //temp3	=	moli->cnp[0];
            //if (temp3 >50) temp3=50;	// temporary code for cnp

	    if (temp1 > temp3) {
	       temp1 = temp3;		// min
	    }

	    if (temp2 < temp3) {
	       temp2 = temp3;		// max
	    }
	 }

	 // output for coloring in VMD

	 for (moli=mol; moli<mol+NMOLS; moli++) {
	    temp3	=	moli->pe;
	    
	    //temp3	=	moli->cnp[0];
	    //if (temp3>50) temp3 = 50;

	    temp3	=	0.7 * (temp3 - temp1)/(temp2-temp1);
	    
	    fprintf(fcolor, "%f ", temp3);

	    //printf("pe %f\n", temp3);
	    //printf("cnp %f\n", temp3);
	 }
	 fprintf(fcolor, "\n");


	 if (M2HDEBUG)	printf("DEBUG: Output configuration files ...\n");
	 
	 // OUTPUT configuration file for further analysis
	 if (confflag) { 
	    output_conf(fconf, timestep);
	 }
	 // OUTPUT .car file for VMD visualization
	 if (carflag) {
	    output_carfile(fcar);
	 }
	 // OUTPUT .pdb file for further analysis
	 if (pdbflag) {
	    output_pdbfile(fpdb, fdat, imagen, imagex, imagey, imagez);
	 }
	 // OUTPUT .xyz file for visualization
	 if (xyzflag) {
	    output_xyzfile(fxyz);
	 }

      } 			// finish ONE input dump file

      fclose(fin);		// close current input dump file

   }				// finish ALL input dump files

   //-------------------------------------------------------------------//
   //	Output final analysis results after ALL frames processed	//
   //-------------------------------------------------------------------//
   if (M2HDEBUG)	printf("DEBUG: ALL FRAMES PROCESSED ...\n");

   //------Frame information------//

   printf("\n# OUTPUT AFTER ALL FRAMES ARE PROCESSED\n\n");
   printf("START TIMESTEP\t%d\n", starttime);
   printf("END TIMESTEP\t%d\n", endtime);
   printf("TOTAL FRAMES\t%d\n", nframe+1);
   printf("ANALYZE EVERY\t%d\n", dnframe);
   printf("ANALYZED FRAMES\t%d\n", nframe/dnframe+1);
   
   //------Output density profile------//
   
   printf("\n# DENSITY PROFILE\n\n");
   for (i=0; i<DEN_BIN; i++) {
      printf("%ld\t%lf\n", i, density[i]);
   }
   printf("%d\t%lf\n", DEN_BIN, density[0]);
 
   //------Output velocity stat.------//

   printf("\n# VELOCITY PROFILE\n\n");
   printf("velmax= %lf\t, velmin= %lf\n", velmax, velmin);
   printf("v2= %lf\t, vf2= %lf\t, vcom2= %lf\n", v2, vf2, vcom2);
   printf("v2= %lf\t, vf2= %lf\t, vcom2= %lf\n", v2, vf2, vcom2*NSITES);
   for (i=0; i<101; i++) {
      printf("%lf\t%lf\t%lf\n", vel_distx[i], vel_disty[i], vel_distz[i]);
   }

   //------Output correlations------//

   printf("\n# TIME CORRELATION FUNCTIONS\n\n");
   corr_norm();			// normalize correlation function
   corr_print();		// print out correlation function

   //------Output distributions------//

   printf("\n# DISTRIBUTIONS\n\n");
   S_PrintAll();		// print out distributions
   //radial("print");		// print out radial distribution function
				// -- has some problem, segmentation fault
   //sq4("print");
   //sq(stdout, "print");	// print out structural factor

   /*
   for (i=0; i<180; i++) {
      printf("%ld %ld\n", i, orientdist[i]);
   }
   */

   //------Output xtal bead position------//

   printf("\n# XTAL BEAD POSITION STATISTICS\n\n");
   ltemp1	=	0;
   for (i=0; i<NSITES/NMOLS; i++) {
       ltemp1	+=	xbeadpos[i];
   }
   for (i=0; i<NSITES/NMOLS/10; i++) {			// every 10 beads
       ltemp2	=	0;
       for (j=0; j<10; j++) {
          ltemp2	+=	xbeadpos[i*10+j];
       }
       printf("%ld-%ld \t%ld \t%f\n", i*10, i*10+9, ltemp2, (double)ltemp2/ltemp1);
   }

   //------Average center of mass of chains------//
   //______OUTPUT average center of mass of chains to .pdb file__//

   //-------------------//
   //	Closing files	//
   //-------------------//
   
   if (M2HDEBUG)	printf("DEBUG: Close output files ...\n");

   prog_end	=	time(NULL);
   
   printf("\n# END OF OUTPUT FILE\n");
   printf("%s", asctime(localtime(&prog_end)));
   printf("\nTotal running time was %lf seconds.\n", difftime(prog_end, prog_start));

   if (preflag)		fclose(fhst);
   fclose(fpre);
   
   if (xyzflag)		fclose(fxyz);
   fclose(fcolor);

   if (carflag)		fclose(fcar);
   if (confflag)    	fclose(fconf);
   if (pdbflag)	     {	fclose(fpdb); fclose(fdat);}

   if (Zflag && MPI_myid==0) {				// ONLY process 0 do the following
      fclose(fZfile);
   }
	 
   fclose(stdout);

#ifdef myMPI
   MPI_Finalize();
#endif

   return	0;
}	
//------MAIN program ends------//


//======================//
//	SUBROUTINES	//
//======================//


//==============================================//
//	Output variables for each chain 	//
//	-- Rg, segment info. etc.		//
//	-- output format made similar		//
//	-- to .pre, so that they can		//
//	-- be easily merged			//
//==============================================//
void output_Rg()
{
   static FILE	*fPtr, *fdist;
   molstruct	*moli;
   long		i, j, k, system=0; 
   long		maxid=0, maxRgid=0, minid=0, minRgid=0;
   double	max=0, maxRg=0, min=1e6, minRg=1e6;
   long		head, tail, length, same;
   long		nloop[MAXNMOLS], 	// # of folds for each chain
		nbridge[MAXNMOLS], 
		ntail[MAXNMOLS], 
		nxseg[MAXNMOLS], 
		nfree[MAXNMOLS];
   long		nloop_tot, 		// total # of loop for the system
		nbridge_tot, ntail_tot, 
		nxseg_tot, nfree_tot;
   long		nxbead[MAXNMOLS];	// # of xtal beads on each chain
   long		nnucl[MAXNMOLS];	// # of nuclei each chain enters
   static int 	init=1;

   if (init) {
      init	=	0;
      fPtr	=	fopen("Rg.hst", "w");
      fdist	=	fopen("Rg.dist", "w");

      //=====	Print header in file Rg.hst	=====//

      fprintf(fPtr, "Timestep");
      fprintf(fPtr, " P2");
      fprintf(fPtr, " Xtal");
      fprintf(fPtr, " nmax");
      fprintf(fPtr, " 2ndnmax");
      fprintf(fPtr, " aveR02");		// average R02 of whole system
      fprintf(fPtr, " aveRg2");		// average Rg2 of whole system
      fprintf(fPtr, " avexRg2");	// average Rg2 of chains containing at least one xseg
      fprintf(fPtr, " avemRg2");	// average Rg2 of chains containing at least one xseg

      fprintf(fPtr, " <10>");		// formatting lines

      fprintf(fPtr, " smooth.y");   
      fprintf(fPtr, " smooth.z");   
      fprintf(fPtr, " ntail_tot");
      fprintf(fPtr, " nloop_tot");
      fprintf(fPtr, " nbridge_tot");
      fprintf(fPtr, " nxseg_tot");
      fprintf(fPtr, " nfree_tot");

      fprintf(fPtr, " <18>");		// formatting lines

      fprintf(fPtr, " chain1");		// ID of chain 1, the one has most xtal beads
      fprintf(fPtr, " xchain1");	// # of xtal beads on chain 1
      fprintf(fPtr, " Rg2chain1");	// Rg2 of chain 1
/*
      fprintf(fPtr, " chain2");		// ID of chain 2, the one has 2nd most xtal beads
      fprintf(fPtr, " xchain2");	// # of xtal beads on chain 2
      fprintf(fPtr, " Rg2chain2");	// Rg2 of chain 2
*/
      fprintf(fPtr, " chain3");		// ID of chain 3, the one has smallest Rg2
      fprintf(fPtr, " xchain3");	// # of xtal beads on chain 3
      fprintf(fPtr, " Rg2chain3");	// Rg2 of chain 3

      fprintf(fPtr, " chain4");		// ID of chain 4, the one has largest Rg2
      fprintf(fPtr, " xchain4");	// # of xtal beads on chain 4
      fprintf(fPtr, " Rg2chain4");	// Rg2 of chain 4

      fprintf(fPtr, " <28>");		// formatting lines

      fprintf(fPtr, " aspher");		// aphericity
      fprintf(fPtr, " dr_sys.x");
      fprintf(fPtr, " dr_sys.y");
      fprintf(fPtr, " dr_sys.z");
      fprintf(fPtr, " d2sys");

      fprintf(fPtr, " KEtot KEpec KEcom");
      fprintf(fPtr, "\n");

      //=====	Print header in Rg.dist file	=====//

      fprintf(fdist, "Timestep");
      fprintf(fdist, "\tnmax");
      fprintf(fdist, "\tchain");
      fprintf(fdist, "\tRg2");
      fprintf(fdist, "\tnxbead");
      fprintf(fdist, "\tnnucl");
      fprintf(fdist, "\tnsegment");
      fprintf(fdist, "\tnbridge");
      fprintf(fdist, "\tnxseg");
      fprintf(fdist, "\tnfree");
      fprintf(fdist, "\n");
   }

   //------Variable initialization------//

   for (i=0; i<NMOLS; i++) {
      nloop[i]	=	0;	nbridge[i]	=	0;
      ntail[i]	=	0;	nxseg[i]	=	0;
      nnucl[i]	=	0;	nxbead[i]	=	0;
      nfree[i]	=	0;
   }
   nloop_tot	=	0;	nbridge_tot	=	0;
   ntail_tot	=	0;	nxseg_tot	=	0;
   nfree_tot	=	0;

   //------Perform analysis------//

   for (moli=mol; moli<mol+NMOLS; moli++) {

      // Calculate how many xtal beads on each chain
      k	=	moli-mol;
      for (i=0; i<moli->nsites; i++) {
         nxbead[k]	+=	(moli->nuclid[i]>0 ? 1 : 0);
      }

      // Chain with max xbeads
      if (nxbead[k] > max) {
         max 	= 	nxbead[k];
         maxid	=	k;
      }

      // Chain with max/min Rg
      if (Rg2[k] > maxRg) {
         maxRg		=	Rg2[k];
         maxRgid	=	k;
      }
      if (Rg2[k] < minRg) {
         minRg		=	Rg2[k];
         minRgid	=	k;
      }
   }

   //------Find out the # of nuclei each chain participates------//
   
   for (k=0; k<NMOLS; k++) {
      for (i=0; i<nsegment[k]; i++) {

         if (seg_stat[k][3*i+1] > 0) {
            same	=	0;
            for (j=0; j<i; j++) {
               if (seg_stat[k][3*i+1]==seg_stat[k][3*j+1]) {
                  same	=	1;
                  break;
               }
            }
            if (!same) {       nnucl[k]	++; }
         }
      }
   }

   // Find out how many tails, etc, each chain has
   
   for (k=0; k<NMOLS; k++) {	
      for (j=0; j<nsegment[k]; j++) {

         length	=	seg_stat[k][j*3+2] - seg_stat[k][j*3] + 1;
	 
         if (length<3 || (length<4 && j>0 && j<nsegment[k]-1)) {
            printf("error, smooth does not work\n");
            printf("chain %ld seg %ld head %d tail %d\n", k, j, seg_stat[k][j*3], seg_stat[k][j*3+2]);
         }

         if (seg_stat[k][j*3+1]==-1) {		// amorphous segment
	    head	=	(j==0 ? -1 : seg_stat[k][(j-1)*3+1]);	
            tail	=	(j==nsegment[k]-1 ? -1 : seg_stat[k][(j+1)*3+1]);

            if (head*tail < 0) {		// tail
               ntail[k]		++;
            }
            else if (tail==-1) {		// whole chain in melt
               nfree[k]		++;
            }
            else if (head==tail) {		// fold
               nloop[k]	++;
            }
            else if (head!=tail) {		// bridge
               nbridge[k]	++;
            }
         }
         else if (seg_stat[k][j*3+1]>0) {	// nseg xtal segment
            nxseg[k]	++;
         }
      }
      ntail_tot		+=	ntail[k];
      nloop_tot		+=	nloop[k];	
      nbridge_tot	+=	nbridge[k];
      nxseg_tot		+=	nxseg[k];
      nfree_tot		+=	nfree[k];
   }

   //------Write system variables to Rg.hst------//

   fprintf(fPtr, "%-6ld", timestep);
   fprintf(fPtr, " %4.3f", P2[0]);
   fprintf(fPtr, " %ld", Xtal[0]);
   fprintf(fPtr, " %ld", nmax[0][0]);
   fprintf(fPtr, " %ld", nmax[0][1]);
   fprintf(fPtr, " %6.3f", R02);
   fprintf(fPtr, " %6.3f", aveRg2);
   fprintf(fPtr, " %6.3f", avexRg2);
   fprintf(fPtr, " %6.3f", avemRg2);

   fprintf(fPtr, "\t<10>");				// formatting lines

   fprintf(fPtr, " %ld", (long)(smoothresult.y));	// diff. in nucleus size 
   fprintf(fPtr, " %ld", (long)(smoothresult.z));	// diff. in total xtal
   fprintf(fPtr, " %ld", ntail_tot);
   fprintf(fPtr, " %ld", nloop_tot);
   fprintf(fPtr, " %ld", nbridge_tot);
   fprintf(fPtr, " %ld", nxseg_tot);
   fprintf(fPtr, " %ld", nfree_tot);

   fprintf(fPtr, "\t<18>");			// formatting lines

   fprintf(fPtr, " %ld", maxid);		// chain with max xbead
   fprintf(fPtr, " %ld", nxbead[maxid]);
   fprintf(fPtr, " %6.3f", Rg2[maxid]);

   fprintf(fPtr, " %ld", minRgid);		// chain with min Rg2
   fprintf(fPtr, " %ld", nxbead[minRgid]);
   fprintf(fPtr, " %6.3f", Rg2[minRgid]);

   fprintf(fPtr, " %ld", maxRgid);		// chain with max Rg2
   fprintf(fPtr, " %ld", nxbead[maxRgid]);
   fprintf(fPtr, " %6.3f", Rg2[maxRgid]);

   fprintf(fPtr, "\t<28>");			// formatting lines

   fprintf(fPtr, " %4.3f", asphericity);	// asphericity of the simulation box
   fprintf(fPtr, " %6.3f", dr_sys.x);
   fprintf(fPtr, " %6.3f", dr_sys.y);
   fprintf(fPtr, " %6.3f", dr_sys.z);
   //fprintf(fPtr, " %6.3f", d2initave);		// sq'ed displacement wrt initial conf.
   //fprintf(fPtr, " %6.3f", d2lastave);		// sq'ed displacement wrt last dump conf.
   fprintf(fPtr, " %6.3f", d2sys);
   //fprintf(fPtr, " %6.3f", d2syslast);

   fprintf(fPtr, " %6.3f %6.3f %6.3f", v2*16743.6, vf2*16743.6, vcom2*NSITES*16743.6);
fprintf(fPtr, " %6.3f %6.3f", lam1, amo1);
   fprintf(fPtr, "\n");

/*
   fprintf(fPtr, "TIMESTEP %ld\n", timestep);
   fprintf(fPtr, "%ld\t%ld\t%ld\n", NSYSTEMS, NMOLS, NSITES);
   fprintf(fPtr, "%f %f ", aveRg2, avexRg2);
   fprintf(fPtr, "%ld %ld %ld %ld\n", nloop_tot, nbridge_tot, ntail_tot, nxseg_tot);
*/
//average Rg2, total # of folds, total # of bridges, total # of tails, total # of xseg


   //------Write variables for each chain to Rg.dist------//

   for (i=0; i<NMOLS; i++) {
      fprintf(fdist, "%-6ld", timestep);
      fprintf(fdist, "\t%ld", nmax[0][0]);
      fprintf(fdist, "\t%ld", i);
      fprintf(fdist, "\t%f", Rg2[i]);
      fprintf(fdist, "\t%ld", nxbead[i]);	// # of xtal beads on this chain
      fprintf(fdist, "\t%ld", nnucl[i]);	// # of nuclei attached to this chain
      fprintf(fdist, "\t%d", nsegment[i]);
      fprintf(fdist, "\t%ld", ntail[i]);	// # of tails on this chain
      fprintf(fdist, "\t%ld", nloop[i]);
      fprintf(fdist, "\t%ld", nbridge[i]);
      fprintf(fdist, "\t%ld", nxseg[i]);
      fprintf(fdist, "\t%ld", nfree[i]);
      fprintf(fdist, "\n");
   }

   return;
}

//======================================================================//
//	output_pre(): write pre-analysis results for further analysis	//
//	              These pre-results should be basic but very	//
//		      time-consuming.  So by saving these results in	//
//		      a pre- file we can reuse them later without 	//
//		      calculating them every time.			//
//======================================================================//
void output_pre(FILE *fPtr) 
{
   molstruct	*moli;
   long		i, system=0;

   //------New version------//
   
   // write system variables
   Print_hst(fPtr);

   // write atomic variables
   for (moli=mol; moli<mol+NMOLS; moli++) {
      fprintf(fPtr, "%ld %ld %ld", moli-mol, moli->box, moli->nsites);
      for(i=0; i<moli->nsites; i++)
         fprintf(fPtr, " %f", moli->p2[i]);
      fprintf(fPtr, "\n");
   }
   
   fflush(fPtr);
   return;
}

//==============================================================//
//	read_pre(): read pre-analysis results, see output_pre()	//
//==============================================================//
void read_pre(FILE *fPtr, long timestep) 
{
   char		dummy[255];
   long		id, nsites, system, i;
   long		time	=	-999;
   float	temp;
   molstruct	*moli;

   // new version
   
   do {
      fscanf(fPtr, "%ld", &time);
      
      fscanf(fPtr, "%lf %f %lf", &(v[0].tot), &temp, &(BOX[0].pres));	// Epot, Vol, Pres
      fscanf(fPtr, "%f %f %f", &temp, &temp, &temp);			// Lx, Ly, Lz
      fscanf(fPtr, "%f %f %f", &temp, &temp, &temp);			// xy, xz, yz

      fscanf(fPtr, "%lf %lf %lf", P2+0, P2M+0, P2z+0);
      fscanf(fPtr, "%lf", transfrac+0);
      fscanf(fPtr, "%ld", Xtal+0);
      fscanf(fPtr, "%ld", realXtal+0);
      fscanf(fPtr, "%ld", Nnucl+0);
      fscanf(fPtr, "%ld %ld", &(nmax[0][0]), &(nmax[0][1]));
   
      fscanf(fPtr, "%lf", Q6+0);
      fscanf(fPtr, "%f", &rshift2);

      fscanf(fPtr, "%lf", &(v[0].stretch));
      fscanf(fPtr, "%lf", &(v[0].bending));
      fscanf(fPtr, "%lf", &(v[0].torsion));
      fscanf(fPtr, "%lf", &(v[0].lj));
      fscanf(fPtr, "%lf", &(v[0].ljcorr));
      
      fgets(dummy, sizeof(dummy), fPtr);
      
      v[0].corr		=	v[0].ljcorr;
      v[0].bonded	=	v[0].stretch + v[0].bending + v[0].torsion;
      v[0].nonbonded	=	v[0].lj + v[0].corr;
            
      for (moli=mol; moli<mol+NMOLS; moli++) {
         fscanf(fPtr, "%ld%ld%ld", &id, &system, &nsites);
         for (i=0; i<nsites; i++) {
            fscanf(fPtr, "%lf", moli->p2+i);
         }
      }
   } while (time!=timestep);

   return;
}


//==============================================================//
//	output_xyzfile(): write configuration to .xyz file	//
//==============================================================//
void output_xyzfile(FILE *fPtr)
{
   molstruct	*moli;
   int		i;
   
   fprintf(fPtr, "%ld\n", NSITES);
   fprintf(fPtr, "comments......\n");
   for (moli=mol; moli<mol+NMOLS; moli++) {
      for (i=0; i<moli->nsites; i++) {
	 fprintf(fPtr, "O %f %f %f\n", moli->p[i].x, moli->p[i].y, moli->p[i].z);
      }
   }
   fflush(fPtr);
   return;
}

//==============================================================//
//	output_carfile(): write configuration to .car file	//
//==============================================================//
void output_carfile(FILE *fPtr)
{
   time_t	t	=	time(NULL);
   molstruct	*moli;
   char		s[80], ff[80];
   int		system = 0;			// only one box for now (11/18/2011)
   int		i, n;

   fprintf(fPtr, "!BIOSYM archive 3\n");
   fprintf(fPtr, "PBC=ON\n");
   fprintf(fPtr, "!TIMESTEP %ld\n", timestep);
   fprintf(fPtr, "!DATE %s", asctime(localtime(&t)));
   fprintf(fPtr, "PBC %9.7g %9.7g %9.7g %9.7g %9.7g %9.7g (P1)\n", 
		BOX[system].lx, BOX[system].ly, BOX[system].lz, 90.0, 90.0, 90.0);

   n	=	0;
   for (moli=mol; moli<mol+NMOLS; moli++) {
      if (system==moli->box) {

         MolInBox2(moli);
         for (i=0; i<moli->nsites; i++) {
            //moli->p[i] = MapInBox2(moli->p+i, PBC, system); //temporary

            if (moli->nuclid[i]>0)			// crystal like particle
               sprintf(s, "N%d", n++);			// N: blue color in VMD
            else
               sprintf(s, "O%d", n++);			// O: red color in VMD

	    /*
            if (sizeofnucl[moli->nuclid[i]] == MAXSIZE[system])		// note nuclid index starts from 1
               sprintf(s, "M%ld", n++);
            else if (sizeofnucl[moli->nuclid[i]] -MAXSIZE[system] > -3 && MAXSIZE[system]>=10)
               sprintf(s, "C%ld", n++);
            else if (moli->nuclid[i] >= 1)
               sprintf(s, "O%ld", n++);
            else
               sprintf(s, "H%ld", n++);
	    */

            fprintf(fPtr, "%-5.5s ", s);
            sprintf(s, "M%ld", moli-mol);
            fprintf(fPtr, "%14.8g %14.8g %14.8g ", moli->p[i].x, moli->p[i].y, moli->p[i].z);
            strcpy(ff, "O");
            fprintf(fPtr, "%-4.4s %-6ld ND      %-3.3s 0.000\n", ff, moli-mol, Element(moli->type[i], s));
         } 
      }   
   }
   fprintf(fPtr, "end\nend\n");
   fflush(fPtr);
   return;
}

//======================================================================//
//	output_pdbfile(): write configuration to pdb file and vmd files	//
//======================================================================//
void output_pdbfile(FILE *fPtr, FILE *fdat, long imgn, double imgx, double imgy, double imgz) 
{
   time_t	t	=	time(NULL);
   molstruct	*moli;
   char		atomname;
   int		system = 0;			// only one box for now (11/18/2011)
   int		i, m, n;
   int		drawmol;
   int		nuclid;

   fprintf(fPtr, "HEADER: file created on %s", asctime(localtime(&t)));
   fprintf(fPtr, "CRYST1%9.4f%9.4f%9.4f%7.2f%7.2f%7.2f P 1           1\n", 
        	BOX[system].lx, BOX[system].ly, BOX[system].lz,	90.0, 90.0, 90.0);

   m		=	0;			// molecule sequence number
   n		=	0;			// atom sequence number
   for (moli=mol; moli<mol+NMOLS; moli++) {
      if (system==moli->box) {
         //MolInBox2(moli);

         drawmol	=	0;
         for (i=0; i<moli->nsites; i++) {
	    nuclid	=	moli->nuclid[i];
            if (sizeofnucl[nuclid] == nmax[system][0]) {	// part of the largest nucleus
               drawmol	=	1;
               break;
            }
	 }

	 //rtemp=CenterofMass(moli);
	 //if (rtemp.z < -0.25 * BOX[system].lz) {

         m	++; 
         for (i=0; i<moli->nsites; i++) {
            if (drawmol) {
	       nuclid	=	moli->nuclid[i];
               if (sizeofnucl[nuclid] == nmax[system][0]) {	// nuclid index starts from 1
                  atomname	=	'N';			// N: blue color in VMD
                  fprintf(fdat, " 10");
               }
               else {
                  atomname	=	'O';			// O: red color in VMD
                  fprintf(fdat, " 0");
               }
            }
            else {
	       atomname	=	'C';				// C: cyan color in VMD
	       fprintf(fdat," -1");
	    }

            n	++;
	    fprintf(fPtr, "ATOM  ");			// pdb command, column 1-6
            fprintf(fPtr, "%5d ", n);			// atom number
            fprintf(fPtr, " %c  ", atomname);		// atom name
            fprintf(fPtr, " ");				// alternate location indiator
  	    fprintf(fPtr, " C8");			// residue name
	    fprintf(fPtr, " ");				// column 21
            fprintf(fPtr, " ");				// chain identifier, column 22
	    fprintf(fPtr, "%4d", m);			// residue sequence number, 23-26
	    fprintf(fPtr, " ");				// code for insertion of residues, 27
            fprintf(fPtr, "   ");			// column 28-30
            fprintf(fPtr, "%8.3f%8.3f%8.3f", moli->p[i].x, moli->p[i].y, moli->p[i].z);
            fprintf(fPtr, "%6.2f%6.2f", 1.0, 0.0);	// occupance and temperature
            fprintf(fPtr, "%5.5s", "");
            fprintf(fPtr, "\n"); 

            if (imgn) {			// for image box
               n	++;
               fprintf(fPtr, "ATOM  ");
               fprintf(fPtr, "%5d ", n);
               fprintf(fPtr, " %c  ", atomname);
               fprintf(fPtr, " ");
               fprintf(fPtr, " C8");
               fprintf(fPtr, " ");
               fprintf(fPtr, " ");
               fprintf(fPtr, "%4d", m);
               fprintf(fPtr, " ");
               fprintf(fPtr, "   ");
               fprintf(fPtr, "%8.3f%8.3f%8.3f", 
			moli->p[i].x + imgx, moli->p[i].y+imgy, moli->p[i].z+imgz);
               fprintf(fPtr, "%6.2f%6.2f", 1.0, 0.0);	// occupance and temperature
               fprintf(fPtr, "%5.5s", "");
               fprintf(fPtr, "\n"); 
            }
         } 
	 //}
      }   
   }
   fprintf(fPtr, "END\n");
   fflush(fPtr);
   fflush(fdat);
   return;
}

//======================================================================//
//	output_conf(): write configuration to configuration file	//
//======================================================================//
void output_conf(FILE *fPtr, long timestep) 
{
   molstruct	*moli;
   int		i;

   fprintf(fPtr, "!TIMESTEP %ld\n", timestep);
   fprintf(fPtr, "%ld\t%ld\t%ld\n", NSYSTEMS, NMOLS, NSITES);

   for (i=0; i<NSYSTEMS; i++) {
      fprintf(fPtr, "%lf\t%lf\t%lf\n", BOX[i].lx, BOX[i].ly, BOX[i].lz);
   }

   for (moli=mol; moli<mol+NMOLS; moli++) {
      fprintf(fPtr, "%ld\t%ld\t%ld\n", moli-mol, moli->box, moli->nsites);
      //fprintf(fconf, "%ld\t%ld\t%ld\t%ld\t%ld\n", i, moli.box, moli.nsites, moli.fix, moli.flip);
      //MolInBox(moli);
      for (i=0; i<moli->nsites; i++) 
         fprintf(fPtr, "%ld\t%lf\t%lf\t%lf\n", moli->type[i], moli->p[i].x, moli->p[i].y, moli->p[i].z);
   }
   fflush(fPtr);
   return;
}


//======================================================================//
//	output_Zinput(): write coord. as Z code input file (4/4/13)	//
//======================================================================//
void output_Zinput(FILE *fPtr)			// Output conf. as Z code input file
{
   //FILE		*fPtr;
   int		system = 0;
   int		i, j;

   //fPtr	=	fopen("Z_initconfiguration", "w");

   fprintf(fPtr, "%d  %ld  %d\n", 3, NMOLS, 0);
   fprintf(fPtr, "%lf  %lf  %lf\n", BOX[system].lx, BOX[system].ly, BOX[system].lz);
   fprintf(fPtr, "%f   %f\n", 1.0, 0.0);
   for (i=0; i<NMOLS; i++) {
      fprintf(fPtr, "%ld  ", (mol+i)->nsites);
   }
   fprintf(fPtr, "\n");

   for (i=0; i<NMOLS; i++) {
      for (j=0; j<(mol+i)->nsites; j++) {
	 fprintf(fPtr, "%lf  %lf  %lf\n", (mol+i)->p[j].x, (mol+i)->p[j].y, (mol+i)->p[j].z);
      }
   }

   //fclose(fPtr);
   return;
}
